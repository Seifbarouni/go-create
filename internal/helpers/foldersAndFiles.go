package helpers

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strings"

	colorize "github.com/Seifbarouni/go-create/internal/colorizeText"
)

func CreateFolder(folderName string) {
	// check if the folder exists
	if _, err := os.Stat(folderName); err == nil {
		colorize.PrintWithColor(fmt.Sprintf("Folder %s already exists\n", folderName), colorize.Yellow)
		os.Exit(1)
	}
	// create the folder
	err := os.Mkdir(folderName, 0755)
	if err != nil {
		colorize.PrintWithColor(err.Error(), colorize.Red)
		os.Exit(1)
	}
	// move to the folder
	err = os.Chdir(folderName)
	if err != nil {
		colorize.PrintWithColor("Error moving to folder", colorize.Red)
		os.Exit(1)
	}
}

func CreateFile(fileName string, content string) {
	// create the file
	file, err := os.Create(fileName)
	if err != nil {
		colorize.PrintWithColor(fmt.Sprintf("Error creating %s file", fileName), colorize.Red)
		os.Exit(1)
	}
	defer file.Close()

	// write the content
	if content != "" {
		_, err = file.WriteString(content)
		if err != nil {
			colorize.PrintWithColor(fmt.Sprintf("Error writing to file %s", fileName), colorize.Red)
			os.Exit(1)
		}
	}
}

func ExecuteCommand(command ...string) {
	cmd := exec.Command(command[0], command[1:]...)

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	err := cmd.Run()
	if err != nil {
		colorize.PrintWithColor(fmt.Sprintf("Error executing command %s", command), colorize.Red)
		os.Exit(1)
	}

}

// create folder and add README.md file
func AddFolderAndReadme(folderName string, content string) {
	colorize.PrintWithColor(fmt.Sprintf("Creating %s folder...\n", folderName), colorize.Purple)
	// create the folder
	CreateFolder(folderName)

	// create the file
	CreateFile("README.md", content)

	// go back to the root folder
	err := os.Chdir("..")
	if err != nil {
		colorize.PrintWithColor("Error moving to folder", colorize.Red)
		os.Exit(1)
	}
	colorize.PrintWithColor(fmt.Sprintf("Folder %s created\n", folderName), colorize.White)
}

func GetSeperator() string {
	os := runtime.GOOS
	if os == "windows" {
		return "\\"
	}
	return "/"
}

func ValidateFolderName(folderName string) bool {
	// check if the folder name is valid and does not contain spaces and special characters
	if len(folderName) < 1 || len(folderName) > 50 {
		return false
	}

	for _, char := range folderName {
		if char == ' ' || char == '\\' || char == '/' || char == ':' || char == '*' || char == '?' || char == '"' || char == '<' || char == '>' || char == '|' {
			return false
		}
	}

	return true
}

func AddPublicAndPrivateRoutes() {
	// go to the routes folder
	err := os.Chdir("routes")
	if err != nil {
		colorize.PrintWithColor("Error moving to folder", colorize.Red)
		os.Exit(1)
	}
	// create publicRoutes.go file
	CreateFile("publicRoutes.go", "//GENERATED BY go-create\npackage routes\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nfunc PublicRoutes(app *fiber.App) {\n\tapp.Get(\"/\", func(c *fiber.Ctx) error  {\n\t\treturn c.JSON(\"Hello World!\")\n\t})\n}")
	// create privateRoutes.go file
	CreateFile("privateRoutes.go", "//GENERATED BY go-create\npackage routes\n\nimport (\n\t\"github.com/gofiber/fiber/v2\"\n)\n\nfunc PrivateRoutes(app *fiber.App) {\n\tapp.Get(\"/\", func(c *fiber.Ctx) error {\n\t\treturn c.JSON(\"Hello World!\")\n\t})\n}")
	// go to the parent folder
	err = os.Chdir("..")
	if err != nil {
		colorize.PrintWithColor("Error moving to folder", colorize.Red)
		os.Exit(1)
	}
}

func GetModuleName() string {
	// go to the root folder
	err := os.Chdir("..")
	if err != nil {
		colorize.PrintWithColor("Error moving to folder", colorize.Red)
		os.Exit(1)
	}
	// read the first line of the go.mod file
	file, err := os.Open("go.mod")
	if err != nil {
		colorize.PrintWithColor("Error opening go.mod file", colorize.Red)
		os.Exit(1)
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	scanner.Scan()

	firstLine := scanner.Text()

	return strings.Split(firstLine, " ")[1]

	// V2
	/*
		i := 0
		for i < 4 {
			fmt.Println(i)
			err := os.Chdir("..")
			if err != nil {
				colorize.PrintWithColor("Error moving to folder", colorize.Red)
				os.Exit(1)
			}
			// read the first line of the go.mod file
			file, err := os.Open("go.mod")
			if err != nil {
				fmt.Println(err.Error())
				i++
				continue
			}
			defer file.Close()
			scanner := bufio.NewScanner(file)
			scanner.Scan()

			firstLine := scanner.Text()

			return strings.Split(firstLine, " ")[1]
		}
		colorize.PrintWithColor("Error reading go.mod file", colorize.Red)
		os.Exit(1)
		return ""
	*/
}
